Index: /Users/asurin/src/edk2/Clover/rEFIt_UEFI/Platform/Settings.c
===================================================================
--- /Users/asurin/src/edk2/Clover/rEFIt_UEFI/Platform/Settings.c	(revision 4243)
+++ /Users/asurin/src/edk2/Clover/rEFIt_UEFI/Platform/Settings.c	(working copy)
@@ -549,7 +549,7 @@
         DBG ("Using %s.plist at SelfRootDir at path: %s\n", ConfName, ConfigPlistPath);
       }
     }
-  } 
+  }
 
   if (!EFI_ERROR (Status) && gConfigPtr != NULL) {
     Status = ParseXML ((const CHAR8*)gConfigPtr, Dict, (UINT32)Size);
@@ -861,17 +861,17 @@
   if (Prop != NULL || gBootChanged) {
     Patches->KPLapicPanic = IsPropertyTrue (Prop);
   }
-  
+
   Prop = GetProperty (DictPointer, "KernelIvyXCPM");
   if (Prop != NULL || gBootChanged) {
     Patches->KPIvyXCPM = IsPropertyTrue (Prop);
   }
 
-    /*
+
   Prop = GetProperty(DictPointer, "KernelHaswellE");
   if (Prop != NULL || gBootChanged) {
     Patches->KPHaswellE = IsPropertyTrue(Prop);
-  }*/
+  }
 
   Prop = GetProperty (DictPointer, "ATIConnectorsController");
   if (Prop != NULL) {
@@ -1019,11 +1019,11 @@
         if (Dict != NULL) {
           //this is impossible because UnicodeStrToAsciiStr not extend output size
  //         UnicodeStrToAsciiStr(PoolPrint(L"%a (%a)", KextPatchesLabel, Dict->string), KextPatchesLabel);
-          
+
           AsciiStrCatS(KextPatchesLabel, 255, " (");
           AsciiStrCatS(KextPatchesLabel, 255, Dict->string);
           AsciiStrCatS(KextPatchesLabel, 255, ")");
-          
+
         } else {
           AsciiStrCatS(KextPatchesLabel, 255, " (NoLabel)");
         }
@@ -1030,11 +1030,11 @@
 
 
         DBG (" %a", KextPatchesLabel);
-        
+
         Patches->KextPatches[Patches->NrKexts].MenuItem.BValue     = TRUE;
         Dict = GetProperty (Prop2, "Disabled");
         if ((Dict != NULL) && IsPropertyTrue (Dict)) {
-          
+
           Patches->KextPatches[Patches->NrKexts].MenuItem.BValue     = FALSE;
         }
 
@@ -1050,7 +1050,7 @@
         Patches->KextPatches[Patches->NrKexts].DataLen      = FindLen;
         Patches->KextPatches[Patches->NrKexts].Patch        = AllocateCopyPool (FindLen, TmpPatch);
         Patches->KextPatches[Patches->NrKexts].MatchOS      = NULL;
-        Patches->KextPatches[Patches->NrKexts].MatchBuild   = NULL;        
+        Patches->KextPatches[Patches->NrKexts].MatchBuild   = NULL;
         Patches->KextPatches[Patches->NrKexts].Name         = AllocateCopyPool (AsciiStrSize(KextPatchesName), KextPatchesName);
         Patches->KextPatches[Patches->NrKexts].Label        = AllocateCopyPool (AsciiStrSize(KextPatchesLabel), KextPatchesLabel);
 
@@ -1185,7 +1185,7 @@
       }
     }
   }
-  
+
   Prop = GetProperty (DictPointer, "BootPatches");
   if (Prop != NULL) {
     INTN   i, Count = GetTagCount (Prop);
@@ -1197,7 +1197,7 @@
     if (Count > 0) {
       TagPtr        Prop2 = NULL, Dict = NULL;
       KERNEL_PATCH  *newPatches = AllocateZeroPool (Count * sizeof(KERNEL_PATCH));
-      
+
       Patches->BootPatches = newPatches;
       DBG ("BootPatches: %d requested\n", Count);
       for (i = 0; i < Count; i++) {
@@ -1209,13 +1209,13 @@
           DBG (" - [%02d]: error %r getting next element\n", i, Status);
           continue;
         }
-        
+
         if (Prop2 == NULL) {
           break;
         }
-        
+
         DBG (" - [%02d]:", i);
-        
+
         Dict = GetProperty (Prop2, "Comment");
         if (Dict != NULL) {
           BootPatchesLabel = AllocateCopyPool (AsciiStrSize (Dict->string), Dict->string);
@@ -1222,20 +1222,20 @@
         } else {
           BootPatchesLabel = AllocateCopyPool (8, "NoLabel");
         }
-        
+
         DBG (" %a", BootPatchesLabel);
-        
+
         Dict = GetProperty (Prop2, "Disabled");
         Patches->BootPatches[Patches->NrBoots].MenuItem.BValue   = !IsPropertyTrue (Dict);
-        
+
         TmpData    = GetDataSetting (Prop2, "Find", &FindLen);
         TmpPatch   = GetDataSetting (Prop2, "Replace", &ReplaceLen);
-        
+
         if (!FindLen || !ReplaceLen || (FindLen != ReplaceLen)) {
           DBG (" :: invalid Find/Replace data - skipping!\n");
           continue;
         }
-        
+
         Patches->BootPatches[Patches->NrBoots].Data         = AllocateCopyPool (FindLen, TmpData);
         Patches->BootPatches[Patches->NrBoots].DataLen      = FindLen;
         Patches->BootPatches[Patches->NrBoots].Patch        = AllocateCopyPool (FindLen, TmpPatch);
@@ -1243,28 +1243,28 @@
         Patches->BootPatches[Patches->NrBoots].MatchOS      = NULL;
         Patches->BootPatches[Patches->NrBoots].MatchBuild   = NULL;
         Patches->BootPatches[Patches->NrBoots].Label        = AllocateCopyPool (AsciiStrSize (BootPatchesLabel), BootPatchesLabel);
-        
+
         Dict = GetProperty (Prop2, "Count");
         if (Dict != NULL) {
           Patches->BootPatches[Patches->NrBoots].Count = GetPropertyInteger (Dict, 0);
         }
-        
+
         FreePool(TmpData);
         FreePool(TmpPatch);
         FreePool(BootPatchesLabel);
-        
+
         Dict = GetProperty (Prop2, "MatchOS");
         if ((Dict != NULL) && (Dict->type == kTagTypeString)) {
           Patches->BootPatches[Patches->NrBoots].MatchOS = AllocateCopyPool (AsciiStrSize (Dict->string), Dict->string);
           DBG(" :: MatchOS: %a", Patches->BootPatches[Patches->NrBoots].MatchOS);
         }
-        
+
         Dict = GetProperty (Prop2, "MatchBuild");
         if ((Dict != NULL) && (Dict->type == kTagTypeString)) {
           Patches->BootPatches[Patches->NrBoots].MatchBuild = AllocateCopyPool (AsciiStrSize (Dict->string), Dict->string);
           DBG(" :: MatchBuild: %a", Patches->BootPatches[Patches->NrBoots].MatchBuild);
         }
-        
+
         DBG (" :: data len: %d\n", Patches->BootPatches[Patches->NrBoots].DataLen);
         Patches->NrBoots++;
       }
@@ -1281,16 +1281,16 @@
   INTN i;
   BOOLEAN ret = FALSE;
   struct MatchOSes *mos; // = AllocatePool(sizeof(struct MatchOSes));
-  
+
   if (!MatchOSEntry || !CurrOS) {
     return TRUE; //undefined matched corresponds to old behavior
   }
-  
+
   mos = GetStrArraySeparatedByChar(MatchOSEntry, ',');
   if (!mos) {
     return TRUE; //memory fails -> anyway the patch enabled
   }
-  
+
   for (i = 0; i < mos->count; ++i) {
     // dot represent MatchOS
     if (
@@ -1309,11 +1309,11 @@
 struct
 MatchOSes *GetStrArraySeparatedByChar(CHAR8 *str, CHAR8 sep)
 {
-  struct MatchOSes *mo;  
+  struct MatchOSes *mo;
   INTN len = 0, i = 0, inc = 1, newLen = 0;
   //  CHAR8 *comp = NULL; //unused
   CHAR8 doubleSep[2];
-  
+
   mo = AllocatePool(sizeof(struct MatchOSes));
   if (!mo) {
     return NULL;
@@ -1322,7 +1322,7 @@
 //  DBG("found %d %c in %s\n", mo->count, sep, str);
   len = (INTN)AsciiStrLen(str);
   doubleSep[0] = sep; doubleSep[1] = sep;
-  
+
   if(AsciiStrStr(str, doubleSep) || !len || str[0] == sep || str[len -1] == sep) {
     mo->count = 0;
     mo->array[0] = NULL;
@@ -1329,11 +1329,11 @@
 //    DBG("emtpy string\n");
     return mo;
   }
-  
+
   if (mo->count > 1) {
     //INTN indexes[mo->count + 1];
     INTN *indexes = (INTN *) AllocatePool(mo->count + 1);
-    
+
     for (i = 0; i < len; ++i) {
       CHAR8 c = str[i];
       if (c == sep) {
@@ -1346,11 +1346,11 @@
     indexes[0] = 0;
     // manually add last index
     indexes[mo->count] = len;
-    
+
     for (i = 0; i < mo->count; ++i) {
       INTN startLocation, endLocation;
       mo->array[i] = 0;
-      
+
       if (i == 0) {
         startLocation = indexes[0];
         endLocation = indexes[1] - 1;
@@ -1386,18 +1386,18 @@
    10.10.2 only 10.10.2 (10.10.1 or 10.10.5 will be skipped)
    10.10.x (or 10.10.X), in this case is valid for all minor version of 10.10 (10.10.(0-9))
    */
-  
+
   BOOLEAN ret = FALSE;
   struct MatchOSes *osToc;
   struct MatchOSes *currOStoc;
-  
+
   if (!MatchOS || !CurrOS) {
     return TRUE; //undefined matched corresponds to old behavior
   }
-  
+
   osToc = GetStrArraySeparatedByChar(MatchOS, '.');
   currOStoc = GetStrArraySeparatedByChar(CurrOS,  '.');
-  
+
   if (osToc->count == 2) {
     if (AsciiStrCmp(osToc->array[0], currOStoc->array[0]) == 0
         && AsciiStrCmp(osToc->array[1], currOStoc->array[1]) == 0) {
@@ -1424,9 +1424,9 @@
         ret = TRUE;
       }
     }
-    
+
   }
-  
+
   deallocMatchOSes(osToc);
   deallocMatchOSes(currOStoc);
   return ret;
@@ -1442,17 +1442,17 @@
 VOID deallocMatchOSes(struct MatchOSes *s)
 {
   INTN i;
-  
+
   if (!s) {
     return;
   }
-  
+
   for (i = 0; i < s->count; i++) {
     if (s->array[i]) {
       FreePool(s->array[i]);
     }
   }
-  
+
   FreePool(s);
 }
 // End of MatchOS
@@ -1476,7 +1476,7 @@
 {
   TagPtr Prop, Prop2;
   UINT8 VolumeType = 0;
-  
+
   Prop = GetProperty (DictPointer, "VolumeType");
   if (Prop != NULL) {
     if (Prop->type == kTagTypeString) {
@@ -1489,11 +1489,11 @@
           if (EFI_ERROR (GetElement(Prop, i, &Prop2))) {
             continue;
           }
-          
+
           if (Prop2 == NULL) {
             break;
           }
-          
+
           if ((Prop2->type != kTagTypeString) || (Prop2->string == NULL)) {
             continue;
           }
@@ -2077,7 +2077,7 @@
       Entry->Type = OSTYPE_OTHER;
     }
   }
-  
+
   Entry->VolumeType = GetVolumeType(DictPointer);
   return TRUE;
 }
@@ -2198,7 +2198,7 @@
       Entry->Flags = OSFLAG_UNSET(Entry->Flags, OSFLAG_HIDDEN);
     }
   }
-  
+
   Entry->VolumeType = GetVolumeType(DictPointer);
 
   return TRUE;
@@ -2210,12 +2210,12 @@
 {
   TagPtr Prop, Dict;
   UINTN  j = 128;
-  
+
   Dict = GetProperty (DictPointer, "EDID");
   if (Dict != NULL) {
     Prop = GetProperty (Dict, "Inject");
     gSettings.InjectEDID = IsPropertyTrue(Prop); // default = false!
-    
+
     if (gSettings.InjectEDID){
       //DBG ("Inject EDID\n");
       Prop = GetProperty (Dict, "Custom");
@@ -2230,13 +2230,13 @@
       } else {
         //DBG (" No Custom EDID\n");
       }
-      
+
       Prop = GetProperty (Dict, "VendorID");
       if (Prop) {
         gSettings.VendorEDID = (UINT16)GetPropertyInteger(Prop, gSettings.VendorEDID);
         //DBG("  VendorID = 0x%04lx\n", gSettings.VendorEDID);
       }
-      
+
       Prop = GetProperty (Dict, "ProductID");
       if (Prop) {
         gSettings.ProductEDID = (UINT16)GetPropertyInteger(Prop, gSettings.ProductEDID);
@@ -2268,9 +2268,9 @@
     SpecialBootMode = TRUE;
     FreePool(Value);
   }
-  
-  
 
+
+
   gSettings.KextPatchesAllowed              = TRUE;
   gSettings.KernelAndKextPatches.KPAppleRTC = TRUE;
   gSettings.KernelAndKextPatches.KPDELLSMBIOS = FALSE; // default is false
@@ -2288,10 +2288,10 @@
         GlobalConfig.Timeout = (INT32)GetPropertyInteger (Prop, GlobalConfig.Timeout);
         DBG ("timeout set to %d\n", GlobalConfig.Timeout);
       }
-      
+
       Prop = GetProperty (DictPointer, "SkipHibernateTimeout");
       gSettings.SkipHibernateTimeout = IsPropertyTrue(Prop);
-      
+
       //DisableCloverHotkeys
       Prop = GetProperty (DictPointer, "DisableCloverHotkeys");
       gSettings.DisableCloverHotkeys = IsPropertyTrue (Prop);
@@ -2355,7 +2355,7 @@
       if (IsPropertyTrue (Prop)) {
         GlobalConfig.NeverHibernate = TRUE;
       }
-      
+
       Prop = GetProperty (DictPointer, "StrictHibernate");
       if (IsPropertyTrue (Prop)) {
         GlobalConfig.StrictHibernate = TRUE;
@@ -2567,7 +2567,7 @@
       Prop = GetProperty (DictPointer, "NoCaches");
       if (IsPropertyTrue (Prop)) {
         gSettings.NoCaches = TRUE;
-      } 
+      }
     }
 
     // KernelAndKextPatches
@@ -2942,7 +2942,7 @@
           }
         }
       }
-      
+
       GetEDIDSettings(DictPointer);
     }
 
@@ -2994,10 +2994,10 @@
   REFIT_DIR_ITER    DirIter;
   EFI_FILE_INFO     *DirEntry;
   INTN              NameLen;
-  
+
   ConfigsNum = 0;
   OldChosenConfig = 0;
-  
+
   DirIterOpen(SelfRootDir, OEMPath, &DirIter);
   DbgHeader("Found config plists");
   while (DirIterNext(&DirIter, 2, L"config*.plist", &DirEntry)) {
@@ -3005,7 +3005,7 @@
     if (DirEntry->FileName[0] == L'.') {
       continue;
     }
-    
+
     UnicodeSPrint(FullName, 512, L"%s\\%s", OEMPath, DirEntry->FileName);
     if (FileExists(SelfRootDir, FullName)) {
       if (StriCmp(DirEntry->FileName, L"config.plist") == 0) {
@@ -3017,7 +3017,7 @@
       DBG("- %s\n", DirEntry->FileName);
     }
   }
-  
+
   DirIterClose(&DirIter);
 }
 
@@ -3789,7 +3789,7 @@
     }
     Banner  = NULL;
   }
-  
+
   //Free buttons images
   for (i = 0; i < 4; i++) {
     if (Buttons[i] != NULL) {
@@ -3947,11 +3947,11 @@
       break;
     }
   }
-  
+
   if (ChosenTheme != NULL) {
     FreePool (ChosenTheme);
   }
-  
+
   //  DBG("8\n");
   PrepareFont();
   return Status;
@@ -4279,7 +4279,7 @@
   if (Prop != NULL) {
     gFwFeaturesMask = (UINT32)GetPropertyInteger (Prop, gFwFeaturesMask);
     DBG ("Using FirmwareFeaturesMask from config\n");
- /*   
+ /*
     if (FFM == gFwFeaturesMask) {
       DBG ("Found same FirmwareFeaturesMask in clover and config\n");
       DBG ("FirmwareFeaturesMask: 0x%08x\n", gFwFeaturesMask);
@@ -4314,8 +4314,8 @@
     }
   }
   DBG ("PlatformFeature: 0x%x\n", gPlatformFeature);
-  
 
+
   Prop = GetProperty (DictPointer, "BiosVendor");
   if (Prop != NULL) {
     AsciiStrCpyS (gSettings.VendorName, 64, Prop->string);
@@ -4449,7 +4449,7 @@
         //gBootArgsChanged = TRUE;
         //gBootChanged = TRUE;
       }
-      
+
       Prop                     = GetProperty (DictPointer, "NeverDoRecovery");
       gSettings.NeverDoRecovery  = IsPropertyTrue (Prop);
     }
@@ -4491,7 +4491,7 @@
       }
 
       Prop = GetProperty (DictPointer, "VRAM");
-      gSettings.VRAM = (UINTN)GetPropertyInteger(Prop, (INTN)gSettings.VRAM); //Mb 
+      gSettings.VRAM = (UINTN)GetPropertyInteger(Prop, (INTN)gSettings.VRAM); //Mb
       //
       Prop = GetProperty (DictPointer, "RefCLK");
       gSettings.RefCLK = (UINT16)GetPropertyInteger (Prop, 0);
@@ -4531,7 +4531,7 @@
       if (Prop != NULL) {
         hex2bin (Prop->string, (UINT8*)&gSettings.Dcfg[0], 8);
       }
-        
+
       Prop = GetProperty (DictPointer, "DualLink");
       if (Prop != NULL) {
         gSettings.DualLink = (UINT32)GetPropertyInteger (Prop, gSettings.DualLink);
@@ -4636,7 +4636,7 @@
               DBG (" no PciAddr\n");
               continue;
             }
-            
+
             Dict2 = GetProperty (Prop2, "Comment");
             if (Dict2 != NULL) {
               AsciiStrCatS(Label, 64, Dict2->string);
@@ -5245,7 +5245,7 @@
               gSettings.PatchDsdtLabel[i] = AllocateZeroPool(256);
               AsciiSPrint(gSettings.PatchDsdtLabel[i], 255, "%a", DSDTPatchesLabel);
               DBG(" (%a)", gSettings.PatchDsdtLabel[i]);
-              
+
               FreePool(DSDTPatchesLabel);
 
               gSettings.PatchDsdtMenuItem[i].BValue = TRUE;
@@ -5902,10 +5902,10 @@
 
       Prop                     = GetProperty (DictPointer, "NvidiaWeb");
       gSettings.NvidiaWeb      = IsPropertyTrue (Prop);
-            
+
     }
-    
-    
+
+
     DictPointer = GetProperty (Dict, "BootGraphics");
     if (DictPointer != NULL) {
       Prop = GetProperty (DictPointer, "DefaultBackgroundColor");
@@ -6076,7 +6076,7 @@
       j++;
     }
     // Detect exact version for OS X Recovery
-    
+
    if (RecoveryPlists[j] != NULL) {
       Status = egLoadFile (Entry->Volume->RootDir, RecoveryPlists[j], (UINT8 **)&PlistBuffer, &PlistLen);
       if (!EFI_ERROR (Status) && PlistBuffer != NULL && ParseXML (PlistBuffer, &Dict, 0) == EFI_SUCCESS) {
@@ -6319,7 +6319,7 @@
               AsciiSPrint (gfx->Config, 64, "%a", card_configs[info->cfg_name].name);
               gfx->Ports                  = card_configs[info->cfg_name].ports;
               DBG (" - GFX: Model=%a (ATI/AMD)\n", gfx->Model);
-              
+
               //get mmio
               if (info->chip_family < CHIP_FAMILY_HAINAN) {
                 gfx->Mmio = (UINT8 *)(UINTN)(Pci.Device.Bar[2] & ~0x0f);
@@ -6329,7 +6329,7 @@
               gfx->Connectors = *(UINT32*)(gfx->Mmio + RADEON_BIOS_0_SCRATCH);
    //           DBG(" - RADEON_BIOS_0_SCRATCH = 0x%08x\n", gfx->Connectors);
               gfx->ConnChanged = FALSE;
-              
+
               SlotDevice                  = &SlotDevices[0];
               SlotDevice->SegmentGroupNum = (UINT16)Segment;
               SlotDevice->BusNum          = (UINT8)Bus;
@@ -6654,13 +6654,13 @@
               // 12: Skylake/KabyLake 0x56c (and some Haswell, example 0xa2e0008)
               // 99: Other
               UINT32 LevelMaxW = 0;
-                
+
               switch (gCPUStructure.Model) {
                   case CPU_MODEL_SANDY_BRIDGE:
                   case CPU_MODEL_IVY_BRIDGE:
                       LevelMaxW = 0x07100000;
                       break;
-                      
+
                   case CPU_MODEL_HASWELL:
                   case CPU_MODEL_HASWELL_ULT:
                   case CPU_MODEL_HASWELL_U5:
@@ -6668,13 +6668,13 @@
                   case CPU_MODEL_BROADWELL_HQ:
                       LevelMaxW = (gSettings.IgPlatform != (UINT32)0x0a2e0008) ? 0xad900000 : 0x56c00000;
                       break;
-                      
+
                   case CPU_MODEL_SKYLAKE_U:
                   case CPU_MODEL_KABYLAKE1:
                   case CPU_MODEL_KABYLAKE2:
                       LevelMaxW = 0x56c00000;
                       break;
-                      
+
                   default:
                       break;
               }
@@ -6949,7 +6949,7 @@
         break;
       default:
         //DBG("Read ExternalClock: %d MHz\n", (INT32)(DivU64x32(gSettings.BusSpeed, kilo)));
-		
+
         // for sandy bridge or newer
         // to match ExternalClock 25 MHz like real mac, divide BusSpeed by 4
         gCPUStructure.ExternalClock = gSettings.BusSpeed / 4;
